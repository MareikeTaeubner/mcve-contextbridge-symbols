describe("symbols, iterables vs contextBridge", function () {
  it("should iterate over a native iterable", function () {
    function* generate() {
      for (const i of [1, 2, 3]) {
        yield i;
      }
    }

    const iterable = generate();

    const result = window.test_api.iterate(iterable);

    chai.expect(result).to.deep.equal([1, 2, 3]);
  });

  it("should iterate over a native iterable on non-symbol property", function () {
    function* generate() {
      for (const i of [1, 2, 3]) {
        yield i;
      }
    }

    const iterable = generate();
    iterable.myIterator = iterable[Symbol.iterator];
    delete iterable[Symbol.iterator];

    const result = window.test_api.iterateAlt(iterable);

    chai.expect(result).to.deep.equal([1, 2, 3]);
  });

  it("should iterate over a non-native iterable", function () {
    const values = [1, 2, 3];
    let index = 0;

    const iterable = {
      [Symbol.iterator]: function () {
        return {
          next() {
            if (index >= values.length) {
              return { done: true };
            } else {
              return { value: values[index++] };
            }
          },
        };
      },
    };

    console.log("renderer", iterable[Symbol.iterator]().next);

    const result = window.test_api.iterate(iterable);

    chai.expect(result).to.deep.equal([1, 2, 3]);
  });

  it("should iterate over a non-native iterable on non-symbol property", function () {
    const iterable = {
      myIterator: function () {
        const values = [1, 2, 3];
        let index = 0;

        return {
          next() {
            if (index >= values.length) {
              return { done: true };
            } else {
              return { value: values[index++] };
            }
          },
        };
      },
    };

    const result = window.test_api.iterateAlt(iterable);

    chai.expect(result).to.deep.equal([1, 2, 3]);
  });
});

describe("async iterators", () => {
  it("should iterate over a native async iterable", async () => {
    async function* generate() {
      for (const i of [1, 2, 3]) {
        yield i;
      }
    }

    const asyncIterable = generate();

    const result = await window.test_api.asyncIterate(asyncIterable);

    chai.expect(result).to.deep.equal([1, 2, 3]);
  });

  it("should iterate over a native async iterable on non-symbol property", async () => {
    async function* generate() {
      for (const i of [1, 2, 3]) {
        yield i;
      }
    }

    const asyncIterable = generate();
    asyncIterable.myIterator = asyncIterable[Symbol.asyncIterator];
    delete asyncIterable[Symbol.asyncIterator];

    const result = await window.test_api.asyncIterateAlt(asyncIterable);

    chai.expect(result).to.deep.equal([1, 2, 3]);
  });

  it("should iterate over a non-native async iterable", async () => {
    const values = [1, 2, 3];
    let index = 0;

    const asyncIterable = {
      [Symbol.asyncIterator]: function () {
        return {
          async next() {
            if (index >= values.length) {
              return { done: true };
            } else {
              return { value: values[index++] };
            }
          },
        };
      },
    };

    const result = await window.test_api.asyncIterate(asyncIterable);

    chai.expect(result).to.deep.equal([1, 2, 3]);
  });

  it("should iterate over a non-native async iterable on non-symbol property", async () => {
    const asyncIterable = {
      myIterator: function () {
        const values = [1, 2, 3];
        let index = 0;

        return {
          async next() {
            if (index >= values.length) {
              return { done: true };
            } else {
              return { value: values[index++] };
            }
          },
        };
      },
    };

    const result = await window.test_api.asyncIterateAlt(asyncIterable);

    chai.expect(result).to.deep.equal([1, 2, 3]);
  });
});
